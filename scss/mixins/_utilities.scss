@use "sass:list";
@use "sass:map";
@use "sass:meta";
@use "sass:string";
@use "../config" as *;
@use "../vendor/rfs" as *;

// stylelint-disable scss/dollar-variable-pattern

// Utility generator

// - Utilities can three different types of selectors:
//   - class: .class
//   - attr-starts: [class^="class"]
//   - attr-includes: [class*="class"]
// - Utilities can generate a regular CSS property or a CSS custom property
// - Utilities can be responsive or not
// - Utilities can have pseudo-class variants (e.g., :hover, :focus, :nth-child(2n+1), "& > *", etc.)
//   - Simple pseudo-classes: hover, focus, active, visited, focus-visible, focus-within
//   - Structural pseudo-classes: first-child, last-child, only-child, first-of-type, last-of-type, only-of-type
//   - Functional pseudo-classes: nth-child(n), nth-last-child(n), nth-of-type(n), nth-last-of-type(n)
//   - State pseudo-classes: empty, checked, disabled, required, valid, invalid
//   - Modern pseudo-classes: has, is, where, not
//   - Children selectors: "& > *"

// Helper mixin to generate CSS properties for both legacy and property map approaches
@mixin generate-properties($utility, $propertyMap, $properties, $value) {
  @if $propertyMap != null {
    // New Property-Value Mapping approach
    @each $property, $defaultValue in $propertyMap {
      $actualValue: if(meta.type-of($value) == "map" and map.has-key($value, $property), map.get($value, $property), $defaultValue);
      @if map.get($utility, important) {
        #{$property}: $actualValue !important; // stylelint-disable-line declaration-no-important
      } @else {
        #{$property}: $actualValue;
      }
    }
  } @else {
    // Legacy approach
    @each $property in $properties {
      @if map.get($utility, important) {
        #{$property}: $value !important; // stylelint-disable-line declaration-no-important
      } @else {
        #{$property}: $value;
      }
    }
  }
}

@mixin generate-utility($utility, $infix: "") {
  // Determine if we're generating a class, or an attribute selector
  $selectorType: if(map.has-key($utility, selector), map.get($utility, selector), "class");
  // Then get the class name to use in a class (e.g., .class) or in a attribute selector (e.g., [class^="class"])
  $selectorClass: map.get($utility, class);

  // Get the list or map of values and ensure it's a map
  $values: map.get($utility, values);
  @if meta.type-of($values) != "map" {
    @if meta.type-of($values) == "list" {
      $list: ();
      @each $value in $values {
        $list: map.merge($list, ($value: $value));
      }
      $values: $list;
    } @else {
      $values: (null: $values);
    }
  }

  // Calculate infix once, before the loop
  // Note: $infix already includes the leading dash from breakpoint-infix()
  // $infix: if($infix == "", "", "-" + $infix);

  @each $key, $value in $values {
    $properties: map.get($utility, property);
    $propertyMap: null;
    $customClass: "";

    // Check if property is a map (new Property-Value Mapping approach)
    // @debug "Properties type: #{meta.type-of($properties)}";
    // @debug "Properties: #{$properties}";
    @if meta.type-of($properties) == "map" {
      $propertyMap: $properties;
      // For property maps, we need to determine the class from the utility definition
      $customClass: if(map.has-key($utility, class), map.get($utility, class), "");
    } @else {
      // Legacy approach: Multiple properties are possible, for example with vertical or horizontal margins or paddings
      @if meta.type-of($properties) == "string" {
        $properties: list.append((), $properties);
      }
      // Use custom class if present, otherwise use the first value from the list of properties
      $customClass: if(map.has-key($utility, class), map.get($utility, class), list.nth($properties, 1));
      $customClass: if($customClass == null, "", $customClass);
    }

    // Use custom CSS variable name if present, otherwise default to `class`
    // mdo-do: restore?
    // $css-variable-name: if(map.has-key($utility, css-variable-name), map.get($utility, css-variable-name), map.get($utility, class));

    // Pseudo-class params to generate pseudo-class variants
    $pseudo-classes: if(map.has-key($utility, pseudo-classes), map.get($utility, pseudo-classes), ());
    $state: if(map.has-key($utility, state), map.get($utility, state), ()); // Legacy support

    // $infix: if($customClass == "" and str-slice($infix, 1, 1) == "-", str-slice($infix, 2), $infix);

    // Don't prefix if value key is null (e.g. with shadow class)
    $customClassModifier: if($key, if($customClass == "" and $infix == "", "", "-") + $key, "");

    $selector: "";
    @if $selectorType == "class" {
      // Use the fallback of the first property if no `class` key is used
      @if $customClass != "" {
        $selector: ".#{$customClass + $infix + $customClassModifier}";
      } @else {
        $selector: ".#{$selectorClass + $infix + $customClassModifier}";
      }
    } @else if $selectorType == "attr-starts" {
      $selector: "[class^=\"#{$selectorClass}\"]";
    } @else if $selectorType == "attr-includes" {
      $selector: "[class*=\"#{$selectorClass}\"]";
    }

    // @debug $utility;
    // @debug $selectorType;
    // @debug $selector;
    // @debug $properties;
    // @debug $values;

    #{$selector} {
      @include generate-properties($utility, $propertyMap, $properties, $value);
    }

    // Generate pseudo-class variants
    $all-pseudo-classes: ();

    // Merge legacy state support with new pseudo-classes
    @if $state != () {
      $all-pseudo-classes: list.join($all-pseudo-classes, $state);
    }
    @if $pseudo-classes != () {
      $all-pseudo-classes: list.join($all-pseudo-classes, $pseudo-classes);
    }

    @if $all-pseudo-classes != () {
      @each $pseudo in $all-pseudo-classes {
        // Handle different types of pseudo-classes and selectors
        $pseudo-selector: "";
        $class-suffix: "";

        @if meta.type-of($pseudo) == "map" {
          // Handle complex pseudo-classes with parameters (e.g., nth-child(2n+1))
          $pseudo-name: map.get($pseudo, name);
          $pseudo-param: map.get($pseudo, param);
          $pseudo-selector: ":#{$pseudo-name}(#{$pseudo-param})";
          // Use a simple sanitized version for class name
          $class-suffix: "-#{$pseudo-name}-param";
          #{$selector}#{$class-suffix}#{$pseudo-selector} {
            @include generate-properties($utility, $propertyMap, $properties, $value);
          }
        } @else if string.index($pseudo, "(") {
          // Handle pseudo-classes with parameters as strings (e.g., "nth-child(2n+1)")
          $pseudo-selector: ":#{$pseudo}";
          // Extract pseudo-class name for class suffix
          $pseudo-name: string.slice($pseudo, 1, string.index($pseudo, "(") - 1);
          $class-suffix: "-#{$pseudo-name}-param";
          #{$selector}#{$class-suffix}#{$pseudo-selector} {
            @include generate-properties($utility, $propertyMap, $properties, $value);
          }
        } @else {
          // Handle simple pseudo-classes (e.g., :hover, :focus)
          $pseudo-selector: ":#{$pseudo}";
          $class-suffix: "-#{$pseudo}";
          #{$selector}#{$class-suffix}#{$pseudo-selector} {
            @include generate-properties($utility, $propertyMap, $properties, $value);
          }
        }
      }
    }
  }
}
